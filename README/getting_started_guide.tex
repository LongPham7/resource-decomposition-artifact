% !TeX root = README.tex

\section{Getting Started Guide}

Our artifact, dubbed Hybrid Resource-Aware ML (Hybrid RaML), is a program analysis tool
that takes in an OCaml program and infers its worst-case polynomial cost bound
using the technique Hybrid AARA developed in the paper.
%
Hybrid AARA integrates data-driven resource analysis (i.e., inferring a cost
bound from the runtime cost measurements of the program) and static resource
analysis (i.e., inferring a cost bound from the source code of the program).

The artifact is wrapped inside the accompanying Docker image
\texttt{hybrid\_aara.tar.gz}.
%
Before running it, first install Docker as instructed here:
\url{https://docs.docker.com/engine/install/}.
%
To see if Docker has been installed properly, run
\begin{verbatim}
$ docker --version
Docker version 25.0.3, build 4debf41
\end{verbatim}

Load a Docker image by running
\begin{verbatim}
$ docker load --input hybrid_aara.tar.gz
\end{verbatim}
%
It creates an image named \texttt{hybrid\_aara} and stores it locally on your
%
Docker may create an image with a slightly different name from
\texttt{hybrid\_aara}.
%
To check the name of the image, display all Docker images on your local machine
by running
\begin{verbatim}
$ docker images
\end{verbatim}

To run the image \texttt{hybrid\_aara}, run
\begin{verbatim}
$ docker run --name hybrid_aara -it --rm hybrid_aara
root@fca41f6f696d:/home/hybrid_aara/benchmark_suite/playground#
\end{verbatim}
%
It creates a Docker container (i.e., a runnable instance of the Docker image)
named \texttt{hybrid\_aara} and starts a shell inside the container.
%
If the command does not run properly, you can instead build the image locally on
your machine as instructed in \cref{sec:Build the Docker Image}.

Throughout this document, any command line starting with \texttt{\#} is executed
inside the Docker container, and any command line starting with \texttt{\$} is
executed in your local machine's terminal.

\subsection{Example Program}
\label{sec:Example Program}

The initial working directory \texttt{playground} has a file \texttt{append.ml}.
%
It stores (i) an OCaml function \texttt{append} and (ii) inputs to the function
\texttt{append} for generating runtime cost measurements.
%
To view the function \texttt{append}'s source code, run
\begin{verbatim}
# cat append.ml | head -16
\end{verbatim}

Given two inputs lists, the function \texttt{append} appends the first input to
the second one.
%
For each element in the first input processed by the function, it incurs a cost
ranging from 0.5 to 1.0 (indicated by a code annotation \texttt{Raml.tick}).
%
Therefore, the worst-case cost bound of the function \texttt{append} is $1.0 \cdot M$, where $M$
is the length of the first input list.

Our goal is to infer a sound worst-case bound of the function \texttt{append} by
Hybrid AARA, which integrates data-driven and static resource analyses.
%
The stepping function \texttt{step\_function} called inside function
\texttt{append} is enclosed by a code annotation \texttt{Raml.stat}.
%
This annotation indicates we perform data-driven resource analysis on the
stepping function---the rest of \texttt{append}'s source code is analyzed by
static resource analysis.
%
To perform data-driven analysis, Hybrid AARA first runs the function
\texttt{append} and collect runtime cost measurements of the stepping function
\texttt{step\_function}.
%
The inputs to \texttt{append} used for generating runtime cost measurements are
stored in the second half of the file \texttt{append.ml}.
%
To view these inputs, run
\begin{verbatim}
# cat append.ml | tail -74
\end{verbatim}
%
In our case, we have chosen inputs in such a way that (i) the input sizes grow
exponentially and (ii) the values of list elements are chosen randomly.

Hybrid RaML's executable is the file \texttt{/home/hybrid\_aara/raml/main}.
%
Its location has already been added to the \texttt{PATH} variable so that we can
call Hybrid RaML by running \texttt{main} anywhere in the Docker container's
filesystem.
%
Hybrid AARA (and its implementation Hybrid RaML) provides three modes of hybrid
resource analysis: Hybrid \Opt{}, Hybrid \BayesWC{}, and Hybrid \BayesPC{}.
%
Although the paper also describes purely data-driven resource analysis
(Section~5), which is a special case of hybrid resource analysis, this Getting
Started Guide focuses on hybrid resource analysis of the function
\texttt{append}.

\subsection{Hybrid \Opt{}}

Hybrid \Opt{} uses \underline{opt}imization, specifically linear programming,
for the data-driven part of resource analysis.
%
To perform Hybrid \Opt{} on the \texttt{append} function, run
\begin{verbatim}
# main stat_analyze ticks 1 -m append.ml append -config config_opt.json
\end{verbatim}
%
In the command line, \texttt{stat\_analyze} means we perform Hybrid AARA
(instead of the conventional AARA).
%
The argument \texttt{ticks} means the resource metric of our interest is the
tick metric (instead of heap memory, for example).
%
The argument 1 means we want to infer degree-1 polynomial cost bounds.
%
The argument \texttt{append.ml} specifies the input file name, and the argument
\texttt{append} specifies the function whose cost bound we want to infer.
%
Finally, the argument \texttt{config\_opt.json} is the configuration file for
Hybrid \Opt{}.

In the output printed on the stdout, you should find
\begin{verbatim}
== append :

[int list; int list] -> int list

Non-zero annotations of the argument:
    0.85  <--  ([::(*)], [])

Non-zero annotations of result:

Simplified bound:
    0.85*M
  where
    M is the number of ::-nodes of the 1st component of the argument
\end{verbatim}
%
It means that the cost bound of the function \texttt{append} inferred by Hybrid
\Opt{} is $0.85 \cdot M$, where $M$ is the first input's length.

\subsection{Hybrid \BayesWC{}}

Hybrid \BayesWC{} conducts \underline{Bayes}ian inference on
\underline{w}orst-case \underline{c}osts for the data-driven part of resource
analysis.
%
To perform Hybrid \BayesWC{}, run
\begin{verbatim}
# main stat_analyze ticks 1 -m append.ml append -config config_bayeswc.json
\end{verbatim}
where the configuration file is now \texttt{config\_bayeswc.json}, which
contains hyperparameters for Bayesian inference.
%
The analysis should finish in 50 seconds.
%
Its output on the stdout should be close to
\begin{verbatim}
== append :

  [int list; int list] -> int list

  Non-zero annotations of the argument:
(avg, std) = (   2.18047,   0.633256)  <--
                                         ([::(*)], [])
(avg, std) = ( 0.0101388,  0.0158341)  <--  ([], [::(*)])
(avg, std) = (         0,          0)  <--  ([], [])

  Non-zero annotations of result:
(avg, std) = (         0,          0)  <--
                                   [::(*)]
(avg, std) = (         0,          0)  <--  []

  Simplified bound:
     0.0101388*L + 2.18047*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument
\end{verbatim}
%
Unlike Hybrid Opt{} that infers a single cost bound, Hybrid \BayesWC{} returns a
collection of cost bounds, which approximate their posterior distribution in
Bayesian inference.
%
In the stdout, 0.0101388 is the average degree-one coefficient for the first
input in the posterior distribution, and 2.18047 is the average
coefficient for the second input.

\subsection{Hybrid \BayesPC{}}

Hybrid \BayesPC{} conducts \underline{Bayes}ian inference on
\underline{p}olynomial \underline{c}oefficients for the data-driven part of
resource analysis.
%
To perform Hybrid \BayesPC{}, run
\begin{verbatim}
# main stat_analyze ticks 1 -m append.ml append -config config_bayespc.json
\end{verbatim}
using the configuration file \texttt{config\_bayespc.json}.
%
The analysis should terminate within 90 seconds.
%
The output printed on the stdout should be close to
\begin{verbatim}
== append :

  [int list; int list] -> int list

  Non-zero annotations of the argument:
(avg, std) = (   2.03295,   0.228391)  <--
                                         ([::(*)], [])
(avg, std) = (  0.281939,   0.146543)  <--  ([], [::(*)])
(avg, std) = (  0.164309,  0.0824471)  <--  ([], [])

  Non-zero annotations of result:
(avg, std) = (         0,          0)  <--
                                   [::(*)]
(avg, std) = (         0,          0)  <--  []

  Simplified bound:
     0.164309 + 0.281939*L + 2.03295*M
   where
     L is the number of ::-nodes of the 2nd component of the argument
     M is the number of ::-nodes of the 1st component of the argument
\end{verbatim}
where each coefficient in the inference result \texttt{0.164309 + 0.281939*L +
  2.03295*M} is the average of its posterior distribution.

\subsection{Configuration Files}

Configuration files supplied to Hybrid RaML specify hyperparameters for
linear programming and Bayesian inference.

In the configuration file \texttt{config\_opt.json} for \Opt{},
\texttt{cost\_gaps\_optimization} inside set to true, and
\texttt{coefficients\_optimization} is set to \texttt{Equal\_weights}.
%
The first setting means we optimize not only the coefficients of an overall cost
bound but also the cost gaps (i.e., the gaps between the predicted costs and
observed costs).
%
The second setting means we assign equal weights to all coefficients in an
overall cost bound regardless of their degrees.

The configuration file \texttt{config\_bayeswc.json} for \BayesWC{} specifies
(i) the probabilistic model hyperparameter $\gamma_0$ in Weibull survival
analysis\footnote{See Appendix~B of the updated version of the paper. The
  probabilistic model is also explained in this PyMC tutorial:
  \url{https://www.pymc.io/projects/examples/en/2022.12.0/survival_analysis/bayes_param_survival_pymc3.html}.}
and (ii) the inference hyperparameters such as the number of chains and the
number of iterations to run in a sampling-based Bayesian inference algorithm.

The configuration file \texttt{config\_bayespc.json} for \BayesPC{} contains (i)
the probabilistic model hyperparameters $\gamma_0$ for normal prior
distributions and $\theta_0, \theta_1$ for Weibull prior distributions and (ii)
the inference hyperparameters for reflective Hamiltonian Monte Carlo (HMC) used
in \BayesPC{}.
%
Reflective HMC runs a sampling-based Bayesian inference algorithm within a
feasible region of a linear program.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "README"
%%% End:
